# -*- coding: utf-8 -*-
"""
Created on Mon Jan 16 15:28:42 2023

@author: localadmin

Note on 01/17/2023: When PPG has not timestamp column, our self-derived 
timestamp starts from sample 0, not 1. Unlike in MATLAB code 
R:\ENGR_Chon\Dong\MATLAB\Pulsewatch\Cassey_working\Pulsewatch_alignment\func\my_func_prep_watch_PPG_ACC.m
Line 107: temp_timestamp = (1:size(PPG_file_buffer,1))./fs_PPG;

Warning, 01/30/2023: before gym, datetime.timedelta(seconds cannot accept non int input.
                                                    
Note on 02/06/2023: This should be the main to run PPG with ECG.
"""
import os
import numpy as np
import datetime
import pytz
import matplotlib.pyplot as plt
import pandas as pd
import sys
import scipy.io as sio
from scipy import signal
from operator import itemgetter 
import time
import sys
from pathlib import Path
'''
Copied from main_02_read_ECG.py
'''
from itertools import islice
sys.path.append(os.path.join('..','func_py'))
print(Path.cwd())
from utils import my_func_UID_ECG_final_path
import re
from scipy import interpolate
from utils import my_func_load_acc_txt_after_ppg, \
                    my_func_read_m_log, \
                    my_importdata_as_np, \
                    my_func_interpolate_timestamp_PPG, \
                    my_func_interpolate_watch_data, \
                    my_func_check_interpolation, \
                    my_func_interpolate_watch_data_2_1_1, \
                    my_func_ver_2_timestamp_start_datetime, \
                    my_func_prep_watch_PPG_ACC, \
                    my_interp_Solo_ECG, \
                    my_extract_Solo_ASCII, \
                    my_extract_Solo_Beats, \
                    my_find_nearest, \
                    my_func_Cardea_SOLO_know_patch_A_B, \
                    my_func_load_Solo_Beats, \
                    my_func_load_Solo_ASCII, \
                    my_func_extend_array, \
                    my_func_add_var_to_df, \
                    my_func_save_buffer_df_to_parquet, \
                    my_func_return_row_idx, \
                    my_func_check_start_idx
                    
our_tzone = pytz.timezone('America/New_York')

flag_save_plot = True
HPC_flag = False
fs_PPG = 50 # Hz, it should be passed inside.
fs_ACC = 50 # Hz, not sure if it is 50 or 30 Hz.
fs_ECG = 250


# Get all the UIDs that were generated by MATLAB.
# get_UID_list = r'R:\ENGR_Chon\NIH_Pulsewatch_Database\mat_for_load_Final_Clinical_Trial_Data'
# dir_list_UID = os.listdir(get_UID_list)

# first_3_char = list(set([x[:3] for x in dir_list_UID]))
# first_3_char_unique = [x for x in first_3_char if x[0] == '0' or x[0] == '1']
# first_3_char_unique.sort()


# =============================================================================
#         Main starts here
# =============================================================================


class My_Main_Gen_SOLO_Beats:
    __slots__ = ('HPC_flag',\
                 'UID')
                 # 'root_data_path',\
                 # 'root_output_path',\
                 # 'all_PPG_ACC_file_name_path',\
                 # 'path_numlines_Solo_ECG',\
                 # 'path_beats_loc',\
                 # 'path_beats_rhythm',\
                 # 'path_beats_type',\
                 # 'path_ECG_valid',\
                 # 'path_ECG_raw',\
                 # 'path_ECG_timestamp') # Restrain the attribute
    
    def __init__(self,UID,HPC_flag):
        self.UID = UID
        if HPC_flag == 'True':
            self.HPC_flag = True
        else:
            self.HPC_flag = False
        print('UID is set to:',self.UID,', running on HPC',self.HPC_flag)
        
    def create_paths(self):
        HPC_flag = self.HPC_flag
        UID = self.UID
        if HPC_flag:
            print('Inside HPC')
            root_data_path = r'/scratch/kic14002/doh16101'
            root_output_path = r'/home/doh16101/MATLAB'
            all_PPG_ACC_file_name_path = r'/scratch/kic14002/doh16101/py_for_load_Final_Clinical_Trial_Data'
            path_numlines_Solo_ECG = r'/scratch/kic14002/doh16101/Python_generated_results/Solo_ECG'
            
            # Output path:
            path_beats_loc = os.path.join(r'/scratch/kic14002/doh16101/Parquet_Files/Solo_Beats_Loc',self.UID)
            path_beats_rhythm = os.path.join(r'/scratch/kic14002/doh16101/Parquet_Files/Solo_Beats_Rhythm',self.UID)
            path_beats_type = os.path.join(r'/scratch/kic14002/doh16101/Parquet_Files/Solo_Beats_Type',self.UID)
            path_ECG_valid = os.path.join(r'/scratch/kic14002/doh16101/Parquet_Files/Solo_ECG_Valid',self.UID)
            path_ECG_raw = os.path.join(r'/scratch/kic14002/doh16101/Parquet_Files/Solo_ECG_Raw',self.UID)
            path_ECG_timestamp = os.path.join(r'/scratch/kic14002/doh16101/Parquet_Files/Solo_ECG_Timestamp',self.UID)
            path_beats_plot = os.path.join(r'/scratch/kic14002/doh16101/Parquet_Files/Solo_Beats_Plot',self.UID)
            
            if UID[0] == '0' or UID[0] == '1':
                path_Solo_ECG = r'/scratch/kic14002/doh16101/DAT_files_for_Cardea_Solo/Clinical_Trial'
            elif UID[0] == '3' or UID[0] == '4':
                path_Solo_ECG = r'/scratch/kic14002/doh16101/DAT_files_for_Cardea_Solo/AF_Trial'
            path_PPG_mat_file = r'/scratch/kic14002/doh16101/Real_Time_Algorithm/Output'
        else:
            print('Inside my Linux')
            root_data_path = r'/mnt/r/ENGR_Chon/NIH_Pulsewatch_Database'
            root_output_path = r'/mnt/r/ENGR_Chon/NIH_Pulsewatch_Database'
            all_PPG_ACC_file_name_path = r'/mnt/r/ENGR_Chon/NIH_Pulsewatch_Database/py_for_load_Final_Clinical_Trial_Data'
            path_numlines_Solo_ECG = r'/mnt/r/ENGR_Chon/Dong/Python_generated_results/Solo_ECG'
            
            # Output path:
            path_beats_loc = os.path.join(r'/mnt/r/ENGR_Chon/NIH_Pulsewatch_Database/Parquet_Files/Solo_Beats_Loc',self.UID)
            path_beats_rhythm = os.path.join(r'/mnt/r/ENGR_Chon/NIH_Pulsewatch_Database/Parquet_Files/Solo_Beats_Rhythm',self.UID)
            path_beats_type = os.path.join(r'/mnt/r/ENGR_Chon/NIH_Pulsewatch_Database/Parquet_Files/Solo_Beats_Type',self.UID)
            path_ECG_valid = os.path.join(r'/mnt/r/ENGR_Chon/NIH_Pulsewatch_Database/Parquet_Files/Solo_ECG_Valid',self.UID)
            path_ECG_raw = os.path.join(r'/mnt/r/ENGR_Chon/NIH_Pulsewatch_Database/Parquet_Files/Solo_ECG_Raw',self.UID)
            path_ECG_timestamp = os.path.join(r'/mnt/r/ENGR_Chon/NIH_Pulsewatch_Database/Parquet_Files/Solo_ECG_Timestamp',self.UID)
            path_beats_plot = os.path.join(r'/mnt/r/ENGR_Chon/NIH_Pulsewatch_Database/Parquet_Files/Solo_Beats_Plot',self.UID)
            
            if UID[0] == '0' or UID[0] == '1':
                path_Solo_ECG = r'/mnt/r/ENGR_Chon/NIH_Pulsewatch_Database/DAT_files_for_Cardea_Solo/Mail_Kamran_2022_05_26/Clinical_Trial'
            elif UID[0] == '3' or UID[0] == '4':
                path_Solo_ECG = r'/mnt/r/ENGR_Chon/NIH_Pulsewatch_Database/DAT_files_for_Cardea_Solo/Mail_Kamran_2022_05_26/AF_Trial'
            path_PPG_mat_file = r'/mnt/r/ENGR_Chon/Dong/MATLAB_generate_results/NIH_PulseWatch/Watch_API_1_0_15/Real_Time_Algorithm/Output'
        
        if not os.path.isdir(root_data_path):
            # print(f"{input_path} does not exist, please check!")
            print("root_data_path does not exist, please check")
            print(root_data_path)
            
        return root_data_path,\
                root_output_path,\
                all_PPG_ACC_file_name_path,\
                path_numlines_Solo_ECG,\
                path_beats_loc,\
                path_beats_rhythm,\
                path_beats_type,\
                path_ECG_valid,\
                path_ECG_raw,\
                path_ECG_timestamp,\
                path_beats_plot,\
                path_Solo_ECG,\
                path_PPG_mat_file
    
    def my_main(self):
# for UID in first_3_char_unique:
        UID = self.UID
        HPC_flag = self.HPC_flag
        prev_ECG_path = []
        prev_start_blc_idx = []
        prev_start_blc_idx_for_end = []
        prev_start_spl_idx = 1
        prev_end_spl_idx = 1
        prev_start_Beat_idx = 1 # I put 1 not zero because idx start from idx-1
        
        root_data_path,\
            root_output_path,\
            all_PPG_ACC_file_name_path,\
            path_numlines_Solo_ECG,\
            path_beats_loc,\
            path_beats_rhythm,\
            path_beats_type,\
            path_ECG_valid,\
            path_ECG_raw,\
            path_ECG_timestamp,\
            path_beats_plot,\
            path_Solo_ECG,\
            path_PPG_mat_file = self.create_paths()
        
        if UID[0] == '0' or UID[0] == '1':
            df_2 = pd.read_csv(os.path.join(path_numlines_Solo_ECG,'num_lines_Solo_ECG.csv'))
        elif UID[0] == '3' or UID[0] == '4':
            df_2 = pd.read_csv(os.path.join(path_numlines_Solo_ECG,'num_lines_Solo_ECG_AF_trial.csv'))
            
        if UID[0] == '0' or UID[0] == '1':
            test_PPG_path = os.path.join(root_data_path,'Final_Clinical_Trial_Data',UID+'_final')
        elif UID[0] == '3' or UID[0] == '4':
            if HPC_flag:
                test_PPG_path = os.path.join(root_data_path,'Final_AF_Trial_Data',UID+'_final')
            else:
                test_PPG_path = os.path.join(root_data_path,'AF_trial','Final_AF_Trial_Data',UID+'_final')
        # Load the PPG file name and ACC file name
        df = my_func_load_acc_txt_after_ppg(all_PPG_ACC_file_name_path,UID)
        # All_PPG_file_name = df['All_PPG_file_name']
        print('Run into the main')
        test_ECG_path_A,\
            Patch_A_start_time,\
            test_ECG_path_B,\
            Patch_B_start_time,\
            test_ECG_path_C,\
            Patch_C_start_time,\
            UMass_type,\
            LinearInterp_root = my_func_UID_ECG_final_path(UID,\
                                   HPC_flag,\
                                   root_data_path,\
                                   root_output_path)
    
        add_1_day_flag = False
        prev_m_log_filename = []

        
        
        # if True:
        # for index, row in df.iterrows():
        start_idx = my_func_check_start_idx(path_beats_loc,\
                                    path_beats_rhythm,\
                                    path_beats_type,\
                                    path_ECG_valid,\
                                    path_ECG_raw,\
                                    path_ECG_timestamp,\
                                    df)
        # start_idx = 4123
        for index in range(start_idx, len(df)):
            row = df.iloc[index] # 0 for seg 0000
            
            PPG_file_name = row['All_PPG_file_name']
            ACC_file_name = row['ACC_for_All_PPG_file_name']
    
            print('=== UID',UID,'idx',index,',',PPG_file_name,'===')
            start = time.time()
            # Remember to check if text file exist.
            PPG_file_buffer,_ = my_importdata_as_np(test_PPG_path,
                                                      PPG_file_name)
            ACC_file_buffer,_ = my_importdata_as_np(test_PPG_path,
                                                      ACC_file_name)
            if not prev_m_log_filename == PPG_file_name[:23]:
                # Reduce the times of reading the log file.
                if not len(prev_m_log_filename) == 0:
                    filename_beats_loc = prev_m_log_filename+'_Solo_Beats_Loc.parquet'
                    filename_beats_rhythm = prev_m_log_filename+'_Solo_Beats_Rhythm.parquet'
                    filename_beats_type = prev_m_log_filename+'_Solo_Beats_Type.parquet'
                    filename_ECG_valid = prev_m_log_filename+'_Solo_ECG_Valid.parquet'
                    filename_ECG_raw = prev_m_log_filename+'_Solo_ECG_Raw.parquet'
                    filename_ECG_timestamp = prev_m_log_filename+'_Solo_ECG_Timestamp.parquet'
                    
                    my_func_save_buffer_df_to_parquet(path_beats_loc,filename_beats_loc,\
                                                          df_buffer_beats_loc)
                    my_func_save_buffer_df_to_parquet(path_beats_rhythm,filename_beats_rhythm,\
                                                          df_buffer_beats_rhythm)
                    my_func_save_buffer_df_to_parquet(path_beats_type,filename_beats_type,\
                                                          df_buffer_beats_type)
                    my_func_save_buffer_df_to_parquet(path_ECG_valid,filename_ECG_valid,\
                                                          df_buffer_ECG_valid)
                        
                    my_func_save_buffer_df_to_parquet(path_ECG_raw,filename_ECG_raw,\
                                                          df_buffer_ECG_raw)
                    my_func_save_buffer_df_to_parquet(path_ECG_timestamp,filename_ECG_timestamp,\
                                                          df_buffer_ECG_timestamp)
                df_buffer_beats_loc = pd.DataFrame()
                df_buffer_beats_rhythm = pd.DataFrame()
                df_buffer_beats_type = pd.DataFrame()
                df_buffer_ECG_valid = pd.DataFrame()
                
                df_buffer_ECG_raw = pd.DataFrame()
                df_buffer_ECG_timestamp = pd.DataFrame()
                
                m_output_struct, \
                    m_time, \
                    m_time_idx,\
                    mylines = my_func_read_m_log(PPG_file_name,test_PPG_path)
                prev_m_log_filename = PPG_file_name[:23]
            
            PPG_raw_buffer,\
            PPG_t_msec,\
            PPG_t_datetime,\
            ACC_raw_buffer,\
            ACC_t_msec,\
            ACC_t_datetime,\
            SamsungHR_buffer,\
            SamsungHR_t_msec,\
            SamsungHR_t_datetime,\
            PPG_timestamp_start,\
            PPG_timestamp_end,\
            add_1_day_flag,\
            PPG_t_msec_ver_2,\
            PPG_t_datetime_ver_2,\
            ACC_t_msec_ver_2,\
            ACC_t_datetime_ver_2,\
            PPG_timestamp_ver_2_raw,\
            ACC_timestamp_ver_2_raw = my_func_prep_watch_PPG_ACC(PPG_file_buffer,\
                                            ACC_file_buffer,\
                                            fs_PPG,\
                                            fs_ACC,\
                                            PPG_file_name,\
                                            test_PPG_path,\
                                            UID,\
                                            add_1_day_flag,\
                                            m_output_struct, \
                                            m_time, \
                                            m_time_idx,\
                                            mylines)
            end = time.time()
            print('Part 1, load PPG and ACC:',end - start,'sec')
    
            
            dir_list = os.listdir(path_Solo_ECG)
            
            if UID[0] == '0' or UID[0] == '1':
                patch_A_Solo_ECG_name = [x for x in dir_list if UID+'A' in x]
                patch_B_Solo_ECG_name = [x for x in dir_list if UID+'B' in x]
                patch_C_Solo_ECG_name = [x for x in dir_list if UID+'C' in x]
            elif UID[0] == '3' or UID[0] == '4':
                patch_A_Solo_ECG_name = [x for x in dir_list if UID in x]
                patch_B_Solo_ECG_name = []
                patch_C_Solo_ECG_name = []
            start = time.time()
            ECG_path,ECG_Date_string = my_func_Cardea_SOLO_know_patch_A_B(patch_A_Solo_ECG_name,\
                                                    Patch_A_start_time,\
                                                    patch_B_Solo_ECG_name,\
                                                    Patch_B_start_time,\
                                                    patch_C_Solo_ECG_name,\
                                                    Patch_C_start_time,\
                                                    PPG_timestamp_start,\
                                                    fs_ECG,\
                                                    df_2,\
                                                    path_Solo_ECG)
            end = time.time()
            print('Part 2, my_func_Cardea_SOLO_know_patch_A_B:',end - start,'sec')
            
            if len(ECG_path) == 0 and len(ECG_Date_string) == 0:
                print('No ECG for this PPG seg.',PPG_file_name)
                continue
            start = time.time()
            ECG_init_datetime = our_tzone.localize(datetime.datetime.strptime(ECG_Date_string, '%m/%d/%Y %H:%M:%S.%f'))
            flag_Beat_for_1 = False
            if not ECG_path == prev_ECG_path:
                # Switch to a new patch:
                flag_Beat_for_1 = True
                Solo_Beat_Location, Solo_Beat_Type, Solo_Beat_Rhythm = my_func_load_Solo_Beats(ECG_path)
                prev_ECG_path = ECG_path
                
                lastname_firstname,\
                    start_date_duration,\
                    Solo_time_intv,\
                    patient_events = my_func_load_Solo_ASCII(ECG_path)
                    
                blocks_datetime = [ECG_init_datetime + datetime.timedelta(milliseconds=float(tt)*1000) for tt in Solo_time_intv] 
            
            if len(prev_ECG_path) == 0:
                prev_ECG_path = ECG_path
                
            end = time.time()
            print('Part 3-1:',end - start,'sec')
            # clinical_ECG_root = os.path.join(root_data_path,'DAT_files_for_Cardea_Solo','Mail_Kamran_2022_05_26','Clinical_Trial')
            # 
            # matches = [x for x in my_dictionary_sentence if x in dir_list]
    
    
                
            
            start = time.time()
            # =============================================================================
            # Search the block to be used
            # =============================================================================
            start_blc_idx = -1 # It should start from one, not zero. 
            for idx in range(1,len(blocks_datetime)):
                if PPG_timestamp_start >= blocks_datetime[idx-1] and PPG_timestamp_start <= blocks_datetime[idx]:
                    start_blc_idx = idx
                    break
            
            # Check if end PPG time is in another ECG.
            start_blc_idx_for_end = -1 # It should start from one, not zero. 
            for idx in range(1,len(blocks_datetime)):
                if PPG_timestamp_end >= blocks_datetime[idx-1] and PPG_timestamp_end <= blocks_datetime[idx]:
                    start_blc_idx_for_end = idx
                    break
            
            # if start_blc_idx == 0:
            #     print('Reset start block index to 1')
            #     start_blc_idx = 1 # I know it should start from 0.
                
            # if start_blc_idx_for_end == 0:
            #     print('Reset end index to 1')
            #     start_blc_idx_for_end = 1 # I know it should start from 0.
                
            # One of the pointer is [].
            if start_blc_idx == -1:
                if start_blc_idx_for_end == -1:
                    print('No ECG for this PPG segment.',PPG_file_name)
                    flag_no_ECG = True
                else:
                    start_blc_idx = 0
                    flag_no_ECG = False
            else:
                if start_blc_idx_for_end == -1:
                    start_blc_idx_for_end = len(blocks_datetime) - 1
                    flag_no_ECG = False
                else:
                    flag_no_ECG = False
            
    
            flag_span_two_blocks = False
            if flag_no_ECG:
                raw_Solo_ECG_array = []
                raw_Solo_ECG_datetime = []
                print('No ECG for this PPG segment.',PPG_file_name)
                continue
            else:
                flag_start_from_1 = False
                if not prev_start_blc_idx == start_blc_idx or \
                    not prev_start_blc_idx_for_end == start_blc_idx_for_end:
                        
                    flag_start_from_1 = True
                    print('Interpolating ECG again')
                    sample_datetime,xq_Linear_Interp,\
                        vq_Linear_Interp= my_interp_Solo_ECG(start_blc_idx,\
                                           fs_ECG,\
                                           Solo_time_intv,\
                                           ECG_init_datetime)
                        
                    if not start_blc_idx == start_blc_idx_for_end:
                        if start_blc_idx_for_end > start_blc_idx:
                            sample_datetime_for_end,\
                                xq_Linear_Interp_for_end,\
                                vq_Linear_Interp_for_end = my_interp_Solo_ECG(start_blc_idx_for_end,\
                                                   fs_ECG,\
                                                   Solo_time_intv,\
                                                   ECG_init_datetime)
                            sample_datetime.extend(sample_datetime_for_end)
                            xq_Linear_Interp = np.concatenate((xq_Linear_Interp,xq_Linear_Interp_for_end))
                            vq_Linear_Interp = np.concatenate((vq_Linear_Interp,vq_Linear_Interp_for_end))
                            flag_span_two_blocks = True
                            print('PPG span two ECG sample blocks, concatenated two.')
                        else:
                            print('End PPG index is in a sample block earlier than start PPG index, check!')    
                # =============================================================================
                # find the ECG segment in the text file.
                # =============================================================================
                if flag_start_from_1:
                    for_loop_start_idx = 1
                    for_loop_end_idx = 1
                else:
                    for_loop_start_idx = prev_start_spl_idx
                    for_loop_end_idx = prev_end_spl_idx
                
                # print('HERE: for_loop_start_idx:',for_loop_start_idx)
                # print('HERE: len(sample_datetime):',len(sample_datetime))
                # print('PPG_timestamp_start',PPG_timestamp_start)
                # print('sample_datetime[idx-1]',sample_datetime[for_loop_start_idx-1])
                # print('sample_datetime[len(sample_datetime)-1]',sample_datetime[len(sample_datetime)-1])
                
                # Dong, 03/06/2023:
                if PPG_timestamp_start <= sample_datetime[for_loop_start_idx-1]:
                    for_loop_start_idx = 1 # Directly reset to one to avoid confusion.
                start_spl_idx = 1 # It should start from one, not zero. 
                for idx in range(for_loop_start_idx,len(sample_datetime)):
                    if PPG_timestamp_start >= sample_datetime[idx-1] and PPG_timestamp_start <= sample_datetime[idx]:
                        start_spl_idx = idx-1
                        # print('HERE-2: found start_spl_idx',start_spl_idx)
                        break
                
                prev_start_spl_idx = start_spl_idx
                start_spl_idx_txt = start_spl_idx + xq_Linear_Interp[0]
                
                if PPG_timestamp_end <= sample_datetime[for_loop_end_idx-1]:
                    for_loop_end_idx = 1 # Directly reset to one to avoid confusion.
                end_spl_idx = 1 # It should start from one, not zero. 
                for idx in range(for_loop_end_idx,len(sample_datetime)):
                    if PPG_timestamp_end >= sample_datetime[idx-1] and PPG_timestamp_end <= sample_datetime[idx]:
                        end_spl_idx = idx-1
                        # print('HERE-3: found end_spl_idx',end_spl_idx)
                        break
                prev_end_spl_idx = end_spl_idx
                end_spl_idx_txt = end_spl_idx + xq_Linear_Interp[0]
                
                filename_Solo_ECG = 'Solo.ECG.txt'
                # this_txt_Solo_ECG = []
                Valid_Solo_ECG_txt = []
                raw_Solo_ECG_txt = []
                # Remember, first row start with <Valid_Sample,Data>
                # print('start_spl_idx_txt',start_spl_idx_txt)
                # print('end_spl_idx_txt',end_spl_idx_txt)
                with open(os.path.join(ECG_path,filename_Solo_ECG)) as f:
                    # for line in islice(f,1, 10): # seq, [start,] stop [, step]
                    for line in islice(f,start_spl_idx_txt, end_spl_idx_txt+1): # seq, [start,] stop [, step]
                        x = line.strip()
                        columns = re.split(',',x)#(r'   ',x)# https://stackoverflow.com/questions/48917121/split-on-more-than-one-space
                        if len(columns) > 1:
                            # print('Debug: columns[1]',columns[1])
                            # print(columns[1] == 'Data')
                            try:
                                int(columns[1])
                            except ValueError:
                                continue
                            # print('columns[1] is numeric')
                            Valid_Solo_ECG_txt.append(columns[0])              # Read the entire file to a string
                            raw_Solo_ECG_txt.append(int(columns[1]))
                        else:
                            print('Solo ECG only has one col, check!')
                            print('Line between',start_spl_idx_txt,'and',end_spl_idx_txt,', Content:',line)
                            Valid_Solo_ECG_txt.append(columns[0])              # Read the entire file to a string
                            raw_Solo_ECG_txt.append([])
                
                raw_Solo_ECG_array = np.array(raw_Solo_ECG_txt)
                print('len(raw_Solo_ECG_array)',len(raw_Solo_ECG_array))
                raw_Solo_ECG_datetime = sample_datetime[start_spl_idx:end_spl_idx+1]
                print('len(raw_Solo_ECG_datetime)',len(raw_Solo_ECG_datetime))
                prev_start_blc_idx = start_blc_idx
                prev_start_blc_idx_for_end = start_blc_idx_for_end
            end = time.time()
            print('Part 3-2-4:',end - start,'sec')
            
            start = time.time()
            # Get the index of not valid SOLO ECG.
            idx_invalid = []
            start_invalid = []
            end_invalid = []
            flag_invalid = False
            for rr in range(len(Valid_Solo_ECG_txt)):
                if flag_invalid == False and Valid_Solo_ECG_txt[rr] == 'F':
                    flag_invalid = True
                    start_invalid.append(rr)
                    
                if flag_invalid == True and Valid_Solo_ECG_txt[rr] == 'T':
                    flag_invalid = False
                    end_invalid.append(rr-1)
                    
                if Valid_Solo_ECG_txt[rr] == 'F':
                    idx_invalid.append(rr)
            
            if flag_invalid == True:
                end_invalid.append(rr-1)
                flag_invalid = False
            # Load the Solo.Beats.txt
            start_Solo_sample_time = vq_Linear_Interp[start_spl_idx]
            end_Solo_sample_time = vq_Linear_Interp[end_spl_idx]
            
            
            
            start_Beat_idx = -1 # It should start from one, not zero. 
            end_Beat_idx = -1 # It should start from one, not zero. 
            
            if flag_Beat_for_1:
                for_loop_start_idx_Beat = 1
            else:
                for_loop_start_idx_Beat = prev_start_Beat_idx
            for idx in range(for_loop_start_idx_Beat,len(Solo_Beat_Location)):
                if start_Beat_idx == -1:
                    if start_Solo_sample_time >= Solo_Beat_Location[idx-1] and start_Solo_sample_time <= Solo_Beat_Location[idx]:
                        start_Beat_idx = idx
                    
                if not start_Beat_idx == -1:
                    if end_Solo_sample_time >= Solo_Beat_Location[idx-1] and end_Solo_sample_time <= Solo_Beat_Location[idx]:
                        end_Beat_idx = idx-1 # If idx, you will exceed the boundary.
                        break
            prev_start_Beat_idx = start_Beat_idx
            
            this_seg_Solo_Beats = Solo_Beat_Location[start_Beat_idx:end_Beat_idx+1]
            this_seg_Solo_Type = Solo_Beat_Type[start_Beat_idx:end_Beat_idx+1]
            this_seg_Solo_Rhythm = Solo_Beat_Rhythm[start_Beat_idx:end_Beat_idx+1]
            
            this_seg_Solo_Beats_datetime = [ECG_init_datetime + datetime.timedelta(milliseconds=float(tt)*1000) for tt in this_seg_Solo_Beats]
            
    
            
            this_seg_Solo_Beats_loc = [my_find_nearest(vq_Linear_Interp,tt) for tt in this_seg_Solo_Beats]
            this_seg_Solo_Beats_loc = np.array(this_seg_Solo_Beats_loc) - start_spl_idx
            end = time.time()
            print('Part 3-3:',end - start,'sec')
            
    # =============================================================================
    # Save ECG beats, valid info, rhythm to csv.
    # =============================================================================
            raw_Solo_ECG_timestamp = vq_Linear_Interp[start_spl_idx:end_spl_idx+1] 
             
            target_len_sig = int(fs_ECG*30+fs_ECG*10) # 30s plus 10 more sec.
            if len(Valid_Solo_ECG_txt) > target_len_sig:
                # print('Default parquet file length',target_len_sig,'is too short')
                # target_len_sig = len(Valid_Solo_ECG_txt)
                # print('Updated target_len_sig to',target_len_sig)
                # UID 035, seg 1347:
                Valid_Solo_ECG_txt = Valid_Solo_ECG_txt[:target_len_sig]
                raw_Solo_ECG_array = raw_Solo_ECG_array[:target_len_sig]
                raw_Solo_ECG_timestamp = raw_Solo_ECG_timestamp[:target_len_sig]
                
                # I should remove the ECG beats that are greater than 10000
                rm_idx = np.argwhere(this_seg_Solo_Beats_loc >= target_len_sig)
                this_seg_Solo_Beats_loc = np.delete(this_seg_Solo_Beats_loc,rm_idx)
                
                for tt in rm_idx.tolist()[::-1]:
                    del this_seg_Solo_Rhythm[tt[0]]
                
                for tt in rm_idx.tolist()[::-1]:
                    del this_seg_Solo_Type[tt[0]]
                
                for tt in rm_idx.tolist()[::-1]:
                    del this_seg_Solo_Beats_datetime[tt[0]]
                
            # my_fig, my_ax = plt.subplots(figsize=(100, 6))
            # my_ax.plot(raw_Solo_ECG_array);
            # Path(r'R:\ENGR_Chon\Dong\Python_generated_results\Debug_Plot').mkdir(parents=True, exist_ok=True)
            # my_fig.savefig(os.path.join(r'R:\ENGR_Chon\Dong\Python_generated_results\Debug_Plot',PPG_file_name[:32]+'_Valid_Solo_ECG_txt.png'), dpi=96, bbox_inches='tight') # Resolution is 300 dpi.
            # plt.close('all')
            file_ECG_valid = my_func_extend_array(target_len_sig,Valid_Solo_ECG_txt)# list
            file_ECG_raw = my_func_extend_array(target_len_sig,raw_Solo_ECG_array) # numpy.ndarray
            file_ECG_timestamp = my_func_extend_array(target_len_sig,raw_Solo_ECG_timestamp)# numpy.ndarray
            
            target_len_beats_loc = int(30*300/60) # Two 30-sec length should be enough.
            if len(this_seg_Solo_Beats_loc) > target_len_beats_loc:
                # print('Default parquet file length',target_len_sig,'is too short')
                # target_len_sig = len(Valid_Solo_ECG_txt)
                # print('Updated target_len_sig to',target_len_sig)
                # UID 035, seg 1347:
                this_seg_Solo_Beats_loc = this_seg_Solo_Beats_loc[:target_len_beats_loc]
                this_seg_Solo_Rhythm = this_seg_Solo_Rhythm[:target_len_beats_loc]
                this_seg_Solo_Type = this_seg_Solo_Type[:target_len_beats_loc]
                this_seg_Solo_Beats_datetime = this_seg_Solo_Beats_datetime[:target_len_beats_loc]
                
            file_beats_loc = my_func_extend_array(target_len_beats_loc,this_seg_Solo_Beats_loc)# numpy.ndarray
            file_beats_rhythm = my_func_extend_array(target_len_beats_loc,this_seg_Solo_Rhythm)# list
            file_beats_type = my_func_extend_array(target_len_beats_loc,this_seg_Solo_Type)# list
    
            df_buffer_beats_loc = my_func_add_var_to_df(file_beats_loc,\
                                                        df_buffer_beats_loc,\
                                                        PPG_file_name)
            df_buffer_beats_rhythm = my_func_add_var_to_df(file_beats_rhythm,\
                                                        df_buffer_beats_rhythm,\
                                                        PPG_file_name)
            df_buffer_beats_type = my_func_add_var_to_df(file_beats_type,\
                                                        df_buffer_beats_type,\
                                                        PPG_file_name)
            df_buffer_ECG_valid = my_func_add_var_to_df(file_ECG_valid,\
                                                        df_buffer_ECG_valid,\
                                                        PPG_file_name)
                
            df_buffer_ECG_raw = my_func_add_var_to_df(file_ECG_raw,\
                                                        df_buffer_ECG_raw,\
                                                        PPG_file_name)
            df_buffer_ECG_timestamp = my_func_add_var_to_df(file_ECG_timestamp,\
                                                        df_buffer_ECG_timestamp,\
                                                        PPG_file_name)
    # =============================================================================
    #       Plotting for ECG and PPG
    # =============================================================================
            
            
            if flag_save_plot:
                # Filter the signal
                [b,a] = signal.butter(3,0.4 /(fs_ECG/2),'highpass')
                # print('len(raw_Solo_ECG_array)',len(raw_Solo_ECG_array))
                # print('raw_Solo_ECG_array',raw_Solo_ECG_array)
                # print('20/(fs_ECG/2)',20/(fs_ECG/2))
                # print('len(raw_Solo_ECG_datetime)',len(raw_Solo_ECG_datetime))
                ## print('raw_Solo_ECG_datetime',raw_Solo_ECG_datetime)
                # print('PPG_timestamp_start',PPG_timestamp_start)
                # print('PPG_timestamp_end',PPG_timestamp_end)
                if len(raw_Solo_ECG_array) < 12:
                    continue
                ECG_highpass_data = signal.filtfilt(b,a,raw_Solo_ECG_array)
                [b,a] = signal.butter(3,20/(fs_ECG/2),'lowpass') #25 /(fs_ECG/2),'low');
                ECG_bandpass_data = signal.filtfilt(b,a,ECG_highpass_data)
                ECG_bandpass_data = ECG_bandpass_data - np.mean(ECG_bandpass_data);
                ECG_filtered_data = ECG_bandpass_data / abs(np.std(ECG_bandpass_data));
        
                # Dong, 03/17/2023, UID 028 seg 12102:
                if len(raw_Solo_ECG_datetime) > len(ECG_filtered_data):
                    print('Before: len(raw_Solo_ECG_datetime)',len(raw_Solo_ECG_datetime))
                    print('Before: len(ECG_filtered_data)',len(ECG_filtered_data))
                    raw_Solo_ECG_datetime = raw_Solo_ECG_datetime[:len(ECG_filtered_data)]
                    print('After: len(raw_Solo_ECG_datetime)',len(raw_Solo_ECG_datetime))
                    print('After: len(ECG_filtered_data)',len(ECG_filtered_data))
                PPG_color = [0, 0.176, 0.8] # Dark blue
                ECG_color = [0,0,0] # Black
                text_normal_color = [0.192, 0.678, 0] # Light green
                text_abnormal_color = [0.980, 0.098, 0.109] # Bright red
                HR1_tachy_color = [0.690, 0.250, 0.266] # Dark red
                HR2_tachy_color = [0.019, 1, 0.043] # Bright green
                ECG_invalid_color = [0.768, 0.768, 0.768] # Light gray
                
                fig = plt.figure(layout=None)
                gs = fig.add_gridspec(nrows=6,ncols=1)
                
                ax1 = fig.add_subplot(gs[0,0])
                my_title = PPG_file_name
                plt.title(my_title,fontsize=20)
                plt.grid()
                # line1, = ax1.plot(pk_loc[1:],HR,'o-',color=HR1_color,label=data_path_GT[(-ext+1):]+' HR')
                line1, = ax1.plot(PPG_t_datetime,PPG_raw_buffer,'-',color=PPG_color,label='PPG raw')
                ax1.set_ylabel('raw PPG',fontsize=20)
                
                # figsrc = plt.figure()
                ax2 = fig.add_subplot(gs[2:4,0],sharex=ax1)
                # my_title = PPG_file_name
                # plt.title(my_title,fontsize=20)
                plt.grid()
                # line1, = ax1.plot(pk_loc[1:],HR,'o-',color=HR1_color,label=data_path_GT[(-ext+1):]+' HR')
                # 
                line2, = ax2.plot(raw_Solo_ECG_datetime,ECG_filtered_data,color=ECG_color,label='ECG raw')
                if len(idx_invalid) > 0:
                    for idx_start,idx_end in zip(start_invalid,end_invalid):
                        line3, = ax2.plot(raw_Solo_ECG_datetime[idx_start:idx_end],\
                                          ECG_filtered_data[idx_start:idx_end],\
                                          color=ECG_invalid_color,\
                                          label='SOLO invalid ECG')
                # line4, = ax2.plot(this_seg_Solo_Beats_datetime,ECG_filtered_data[this_seg_Solo_Beats_loc],'v',markerfacecolor='none',color=HR1_100BPM, markersize=10,label='SOLO Beats')
                # zip joins x and y coordinates in pairs
                if len(this_seg_Solo_Beats_loc) > 0:
                    for x,y,S_type,S_r in zip(this_seg_Solo_Beats_datetime,\
                               ECG_filtered_data[this_seg_Solo_Beats_loc],\
                                   this_seg_Solo_Type,this_seg_Solo_Rhythm):
                        if (S_type == 'N' and S_r == 'N') or \
                            (S_type == 'Q' and S_r == 'N') or \
                            (S_type == 'Z' and S_r == 'N'):
                            color_Solo_beats = text_normal_color
                        else:
                            color_Solo_beats = text_abnormal_color
                        label = S_type+','+S_r
                
                        plt.annotate(label, # this is the text
                                 (x,y), # these are the coordinates to position the label
                                 textcoords="offset points", # how to position the text
                                 xytext=(0,10), # distance from text to points (x,y)
                                 ha='center',
                                 color=color_Solo_beats,
                                 fontweight='bold',
                                 fontsize = 15) # horizontal alignment can be left, right or center
                    
                        line4, = ax2.plot(x,y,'v',markerfacecolor='none',color=color_Solo_beats, markersize=20,label='SOLO Beats')
                
                ax2.set_ylabel('raw ECG (a.u.)',fontsize=20)
                        
                # =============================================================================
                #         Load PPG Peak Det Results
                # =============================================================================
        
                
        
                mat_file_result = sio.loadmat(os.path.join(path_PPG_mat_file,UID,PPG_file_name[:32]+'_realtime_algo_output.mat'))
        
                # To access the content of the struct:
                PPG_peak_loc_WEPD = mat_file_result['output_WEPD']['PPG_peak_loc_WEPD']
                PPG_peak_loc_WEPD = PPG_peak_loc_WEPD[0][0][:,0]
                PPG_peak_loc_WEPD_py = PPG_peak_loc_WEPD - 1
                PPG_peak_loc_WEPD_py = PPG_peak_loc_WEPD_py.astype(np.int16)
        
                HR_PPG_WEPD = mat_file_result['output_WEPD']['HR_PPG_WEPD']
                if len(HR_PPG_WEPD[0][0]) > 0:
                    HR_PPG_WEPD = HR_PPG_WEPD[0][0][:,0]
                else:
                    # UID 108, seg 758
                    HR_PPG_WEPD = 0
                
                
                smooth_PPG_WEPD = mat_file_result['output_WEPD']['smooth_PPG_WEPD']
                smooth_PPG_WEPD = smooth_PPG_WEPD[0][0][:,0]
                
                if smooth_PPG_WEPD.shape[0] < PPG_raw_buffer.shape[0]:
                    compensate_samples = PPG_raw_buffer.shape[0] - smooth_PPG_WEPD.shape[0]
                    smooth_PPG_WEPD = np.concatenate((smooth_PPG_WEPD[:,],np.ones((compensate_samples,))*smooth_PPG_WEPD[-2]))
                # my_fig, my_ax = plt.subplots(figsize=(20, 20))
                # my_ax.plot(smooth_PPG_WEPD,color=PPG_color)
                # Path(r'R:\ENGR_Chon\Dong\Python_generated_results\Debug_Plot').mkdir(parents=True, exist_ok=True)
                # my_fig.savefig(os.path.join(r'R:\ENGR_Chon\Dong\Python_generated_results\Debug_Plot',PPG_file_name[:32]+'_smooth_PPG.png'), dpi=96, bbox_inches='tight') # Resolution is 300 dpi.
                # my_fig, my_ax = plt.subplots(figsize=(20, 20))
                # my_ax.plot(PPG_raw_buffer,color=ECG_color)
                # Path(r'R:\ENGR_Chon\Dong\Python_generated_results\Debug_Plot').mkdir(parents=True, exist_ok=True)
                # my_fig.savefig(os.path.join(r'R:\ENGR_Chon\Dong\Python_generated_results\Debug_Plot',PPG_file_name[:32]+'_raw_PPG.png'), dpi=96, bbox_inches='tight') # Resolution is 300 dpi.
                ax3 = fig.add_subplot(gs[1,0],sharex=ax1)
                # my_title = PPG_file_name
                # plt.title(my_title,fontsize=20)
                plt.grid()
                # line1, = ax1.plot(pk_loc[1:],HR,'o-',color=HR1_color,label=data_path_GT[(-ext+1):]+' HR')
                line4, = ax3.plot(PPG_t_datetime,smooth_PPG_WEPD,'-',color=PPG_color,label='PPG filtered')
                line5, = ax3.plot(itemgetter(*PPG_peak_loc_WEPD_py)(PPG_t_datetime),itemgetter(*PPG_peak_loc_WEPD_py)(smooth_PPG_WEPD),'o',color=PPG_color,label='PPG WEPD HR')
                ax3.set_ylabel('filtered PPG (a.u.)',fontsize=20)
                
                ax4 = fig.add_subplot(gs[4:6,0],sharex=ax1)
                # my_title = PPG_file_name
                # plt.title(my_title,fontsize=20)
                plt.grid()
                # line1, = ax1.plot(pk_loc[1:],HR,'o-',color=HR1_color,label=data_path_GT[(-ext+1):]+' HR')
                if len(PPG_peak_loc_WEPD_py) > 1:
                    line6, = ax4.plot(itemgetter(*PPG_peak_loc_WEPD_py[1:])(PPG_t_datetime),HR_PPG_WEPD,'o-',color=PPG_color,label='PPG WEPD HR')
                ax4.set_ylabel('HR (BPM)',fontsize=20)
                # =============================================================================
                #         Plot the ECG HR
                # =============================================================================
                Solo_HR = 60 / np.diff(this_seg_Solo_Beats_loc) * fs_ECG
                line7, = ax4.plot(this_seg_Solo_Beats_datetime[1:],Solo_HR,'o-',color=ECG_color,label='ECG SOLO HR')
                if len(PPG_peak_loc_WEPD_py) > 1:
                    ax4.legend(handles=[line6, line7],fontsize=20)
                else:
                    ax4.legend(handles=[line7],fontsize=20)
                # =============================================================================
                #         Show the plot now
                # =============================================================================
                plt.xlabel('Time (HH:MM:SS in 24 hour)',fontsize=20)
                # plt.show()
                
                # Save figures for the report.
                fig = plt.gcf()
                fig.set_size_inches(26,15)
                
                Path(path_beats_plot).mkdir(parents=True, exist_ok=True)
                fig.savefig(os.path.join(path_beats_plot,PPG_file_name[:32]+'_Solo_Beats.png'), dpi=96, bbox_inches='tight') # Resolution is 300 dpi.
                # %matplotlib auto
                plt.close('all')
                
        # return PPG_timestamp_start, sample_datetime
if __name__ == '__main__':
    UID = sys.argv[1]
    HPC_flag = sys.argv[2]
    this_main = My_Main_Gen_SOLO_Beats(UID,HPC_flag)
    # PPG_timestamp_start,sample_datetime = this_main.my_main()
    this_main.my_main()
