# -*- coding: utf-8 -*-
"""
Created on Mon Jan 16 15:28:42 2023

@author: localadmin

Note on 01/17/2023: When PPG has not timestamp column, our self-derived 
timestamp starts from sample 0, not 1. Unlike in MATLAB code 
R:\ENGR_Chon\Dong\MATLAB\Pulsewatch\Cassey_working\Pulsewatch_alignment\func\my_func_prep_watch_PPG_ACC.m
Line 107: temp_timestamp = (1:size(PPG_file_buffer,1))./fs_PPG;

Warning, 01/30/2023: before gym, datetime.timedelta(seconds cannot accept non int input.
"""
import os
import numpy as np
import datetime
import pytz
import matplotlib.pyplot as plt
import sys
from scipy import signal

sys.path.append(r'..\func_py')
from utils import my_func_load_acc_txt_after_ppg, \
                    my_func_read_m_log, \
                    my_importdata_as_np, \
                    my_func_interpolate_timestamp_PPG, \
                    my_func_interpolate_watch_data, \
                    my_func_check_interpolation, \
                    my_func_interpolate_watch_data_2_1_1, \
                    my_func_ver_2_timestamp_start_datetime, \
                    my_func_prep_watch_PPG_ACC
                    
our_tzone = pytz.timezone('America/New_York')

fs_PPG = 50 # Hz, it should be passed inside.
fs_ACC = 30 # Hz, not sure if it is 50 or 30 Hz.
root_data_path = r'R:\ENGR_Chon\NIH_Pulsewatch_Database'
all_PPG_ACC_file_name_path = r'R:\ENGR_Chon\NIH_Pulsewatch_Database\py_for_load_Final_Clinical_Trial_Data'

# Get all the UIDs that were generated by MATLAB.
get_UID_list = r'R:\ENGR_Chon\NIH_Pulsewatch_Database\mat_for_load_Final_Clinical_Trial_Data'
dir_list_UID = os.listdir(get_UID_list)

first_3_char = list(set([x[:3] for x in dir_list_UID]))
first_3_char_unique = [x for x in first_3_char if x[0] == '0' or x[0] == '1']
first_3_char_unique.sort()


# =============================================================================
#         Main starts here
# =============================================================================
UID = '017'
# for UID in first_3_char_unique:
if True:
    test_PPG_path = os.path.join(root_data_path,'Final_Clinical_Trial_Data',UID+'_final')
    
    # Load the PPG file name and ACC file name

    df = my_func_load_acc_txt_after_ppg(all_PPG_ACC_file_name_path,UID)
    # All_PPG_file_name = df['All_PPG_file_name']

    add_1_day_flag = False
    if True:
    # for index, row in df.iterrows():
        row = df.iloc[5] # 0 for seg 0000
        print(row)
        PPG_file_name = row['All_PPG_file_name']
        ACC_file_name = row['ACC_for_All_PPG_file_name']

        
        # Remember to check if text file exist.
        PPG_file_buffer,_ = my_importdata_as_np(test_PPG_path,
                                                  PPG_file_name)
        ACC_file_buffer,_ = my_importdata_as_np(test_PPG_path,
                                                  ACC_file_name)

        PPG_raw_buffer,\
        PPG_t_msec,\
        PPG_t_datetime,\
        ACC_raw_buffer,\
        ACC_t_msec,\
        ACC_t_datetime,\
        SamsungHR_buffer,\
        SamsungHR_t_msec,\
        SamsungHR_t_datetime,\
        PPG_timestamp_start,\
        PPG_timestamp_end,\
        add_1_day_flag,\
        PPG_t_msec_ver_2,\
        PPG_t_datetime_ver_2,\
        ACC_t_msec_ver_2,\
        ACC_t_datetime_ver_2,\
        PPG_timestamp_ver_2_raw,\
        ACC_timestamp_ver_2_raw = my_func_prep_watch_PPG_ACC(PPG_file_buffer,\
                                        ACC_file_buffer,\
                                        fs_PPG,\
                                        fs_ACC,\
                                        PPG_file_name,\
                                        test_PPG_path,\
                                        UID,\
                                        add_1_day_flag)
            
        HR1_color = [0, 0.176, 0.8] # Dark blue
        HR2_color = [0.098, 0.439, 0] # Dark green
        HR1_100BPM = [1, 0.2, 0.231] # Light red
        HR2_100BPM = [0.235, 0.839, 0] # Light green
        HR1_tachy_color = [0.690, 0.250, 0.266] # Dark red
        HR2_tachy_color = [0.019, 1, 0.043] # Bright green
            
        figsrc = plt.figure()
        ax1 = plt.subplot(211)
        my_title = PPG_file_name
        plt.title(my_title,fontsize=20)
        plt.grid()
        # line1, = ax1.plot(pk_loc[1:],HR,'o-',color=HR1_color,label=data_path_GT[(-ext+1):]+' HR')
        line1, = ax1.plot(PPG_t_datetime,PPG_raw_buffer,'-',color=HR1_color,label='PPG raw')
        ax1.set_ylabel('a.u.',fontsize=20)
        
        # plt.show()
        
        '''
        Copied from main_02_read_ECG.py
        '''
        from itertools import islice
        import os
        import sys
        sys.path.append(r'..\func_py')
        from utils import my_func_UID_ECG_final_path
        import datetime
        import pytz
        import re
        import numpy as np
        from scipy import interpolate
        import matplotlib.pyplot as plt

        # UID = '017'
        HPC_flag = False
        root_data_path = r'R:\ENGR_Chon\NIH_Pulsewatch_Database'
        root_output_path = r'R:\ENGR_Chon\NIH_Pulsewatch_Database'
        test_ECG_path_A,\
            Patch_A_start_time,\
            test_ECG_path_B,\
            Patch_B_start_time,\
            test_ECG_path_C,\
            Patch_C_start_time,\
            UMass_type,\
            LinearInterp_root = my_func_UID_ECG_final_path(UID,\
                                   HPC_flag,\
                                   root_data_path,\
                                   root_output_path)

        fs_ECG = 250

        our_tzone = pytz.timezone('America/New_York') # This line does not exist in MATLAB code. I do not want to pass it as a variable. 01/19/2023.

        ECG_init_datetime = our_tzone.localize(datetime.datetime.strptime(Patch_A_start_time, '%m/%d/%Y %H:%M:%S.%f'))

        # =============================================================================
        # Load non-linear timestamp from Solo.ASCII.txt
        # =============================================================================
        from bs4 import BeautifulSoup
        path_Solo_ECG = r'R:\ENGR_Chon\NIH_Pulsewatch_Database\DAT_files_for_Cardea_Solo\Mail_Kamran_2022_05_26\Clinical_Trial\Pulsewatch_017A_1950_1_1_2019_12_4'
        filename_Solo_ECG = 'Solo.ASCII.txt'

        # with open(os.path.join(path_Solo_ECG,filename_Solo_ECG)) as f:
        #     text = f.read()
        # soup = BeautifulSoup(text, 'lxml')

        mylines = []
        with open(os.path.join(path_Solo_ECG,filename_Solo_ECG), 'rt') as myfile:  # 'r' for reading, 't' for text mode.
            for myline in myfile:
                x = myline.strip()
                # columns = re.split(r'\s{1,}',x)#(r'   ',x)# https://stackoverflow.com/questions/48917121/split-on-more-than-one-space
                mylines.append(x)              # Read the entire file to a string

        # Solo_time_intv = mylines[7:-3] # Temporary fetch like this.
        Solo_time_intv = mylines[7:-4] # Temporary fetch like this.
        blocks_datetime = [ECG_init_datetime + datetime.timedelta(milliseconds=float(tt)*1000) for tt in Solo_time_intv] 

        # =============================================================================
        # Search the block to be used
        # =============================================================================
        # PPG_timestamp_start = our_tzone.localize(datetime.datetime.strptime('09/16/2019 14:59:30', '%m/%d/%Y %H:%M:%S'))
        # PPG_timestamp_end = our_tzone.localize(datetime.datetime.strptime('09/16/2019 15:00:00', '%m/%d/%Y %H:%M:%S'))

        start_blc_idx = 1 # It should start from one, not zero. 
        for idx in range(1,len(blocks_datetime)):
            if PPG_timestamp_start >= blocks_datetime[idx-1] and PPG_timestamp_start <= blocks_datetime[idx]:
                start_blc_idx = idx-1
                break

        if start_blc_idx == 1:
            # Warning: make sure this starts from 1 and not end with start_blc_idx - 1.
            x_Sample_Value = np.array((1,start_blc_idx * fs_ECG*60*10)) # Every 10-min sample.
            v = [float(0),float(Solo_time_intv[start_blc_idx-1])]
        else:
            x_Sample_Value = np.array((start_blc_idx,start_blc_idx+1)) * (fs_ECG*60*10) # Every 10-min sample.
            v = [float(tt) for tt in Solo_time_intv[start_blc_idx:start_blc_idx+2]]
            
        xq_Linear_Interp = np.arange(x_Sample_Value[0],x_Sample_Value[1]+1) # It should be 150001, not 150000.


        f = interpolate.interp1d(x_Sample_Value, np.array(v), fill_value="extrapolate") # Must put fill_value="extrapolate"
        vq_Linear_Interp = f(xq_Linear_Interp) # interpolated PPG.

        sample_datetime = [ECG_init_datetime + datetime.timedelta(milliseconds=float(tt)*1000) for tt in vq_Linear_Interp]

        # =============================================================================
        # find the ECG segment in the text file.
        # =============================================================================
        start_spl_idx = 1 # It should start from one, not zero. 
        for idx in range(1,len(sample_datetime)):
            if PPG_timestamp_start >= sample_datetime[idx-1] and PPG_timestamp_start <= sample_datetime[idx]:
                start_spl_idx = idx-1
                break

        start_spl_idx_txt = start_spl_idx + xq_Linear_Interp[0]

        end_spl_idx = 1 # It should start from one, not zero. 
        for idx in range(1,len(sample_datetime)):
            if PPG_timestamp_end >= sample_datetime[idx-1] and PPG_timestamp_end <= sample_datetime[idx]:
                end_spl_idx = idx-1
                break
            
        end_spl_idx_txt = end_spl_idx + xq_Linear_Interp[0]

        filename_Solo_ECG = 'Solo.ECG.txt'
        # this_txt_Solo_ECG = []
        Valid_Solo_ECG_txt = []
        raw_Solo_ECG_txt = []
        # Remember, first row start with <Valid_Sample,Data>
        with open(os.path.join(path_Solo_ECG,filename_Solo_ECG)) as f:
            # for line in islice(f,1, 10): # seq, [start,] stop [, step]
            for line in islice(f,start_spl_idx_txt, end_spl_idx_txt+1): # seq, [start,] stop [, step]
                x = line.strip()
                columns = re.split(',',x)#(r'   ',x)# https://stackoverflow.com/questions/48917121/split-on-more-than-one-space
                if len(columns) > 1:
                    Valid_Solo_ECG_txt.append(columns[0])              # Read the entire file to a string
                    raw_Solo_ECG_txt.append(int(columns[1]))
                else:
                    print('Solo ECG only has one col, check!')
                    print('Line between',start_spl_idx_txt,'and',end_spl_idx_txt,', Content:',line)
                    Valid_Solo_ECG_txt.append(columns[0])              # Read the entire file to a string
                    raw_Solo_ECG_txt.append([])

        raw_Solo_ECG_array = np.array(raw_Solo_ECG_txt)
        raw_Solo_ECG_datetime = sample_datetime[start_spl_idx:end_spl_idx+1]

        # Filter the signal
        [b,a] = signal.butter(3,0.4 /(fs_ECG/2),'highpass')
        ECG_highpass_data = signal.filtfilt(b,a,raw_Solo_ECG_array)
        [b,a] = signal.butter(3,20/(fs_ECG/2),'lowpass') #25 /(fs_ECG/2),'low');
        ECG_bandpass_data = signal.filtfilt(b,a,ECG_highpass_data)
        ECG_bandpass_data = ECG_bandpass_data - np.mean(ECG_bandpass_data)
        ECG_filtered_data = ECG_bandpass_data / abs(np.std(ECG_bandpass_data))

        HR1_color = [0, 0.176, 0.8] # Dark blue
        HR2_color = [0.098, 0.439, 0] # Dark green
        HR1_100BPM = [1, 0.2, 0.231] # Light red
        HR2_100BPM = [0.235, 0.839, 0] # Light green
        HR1_tachy_color = [0.690, 0.250, 0.266] # Dark red
        HR2_tachy_color = [0.019, 1, 0.043] # Bright green
            
        # figsrc = plt.figure()
        ax2 = plt.subplot(212)
        # my_title = PPG_file_name
        # plt.title(my_title,fontsize=20)
        plt.grid()
        # line1, = ax1.plot(pk_loc[1:],HR,'o-',color=HR1_color,label=data_path_GT[(-ext+1):]+' HR')
        # 
        line2, = ax2.plot(raw_Solo_ECG_datetime,ECG_filtered_data,color=HR2_color,label='ECG raw')
        ax2.set_ylabel('a.u.',fontsize=20)
                
        plt.show()
        # %matplotlib auto